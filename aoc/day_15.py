from typing import Tuple
import networkx as nx
import numpy as np


def part_one(file_path: str):
    """
    finds the shortest (least risky) path from the top left to bottom right of grid

    Args:
        file_path (str):

    Returns:
        int:
    """

    # read file
    with open(file_path) as f:
        lines = f.readlines()

    X = np.array([[int(x) for x in list(row.strip())] for row in lines])

    return find_shortest_path(X)


def part_two(file_path: str):
    """
    finds the shortest (least risky) path from the top left to bottom right of
    the large grid generated by defined rules


    Args:
        file_path (str):

    Returns:
        [type]: [description]
    """

    with open(file_path) as f:
        lines = f.readlines()

    X = get_big_map(np.array([[int(x) for x in list(row.strip())] for row in lines]))

    return find_shortest_path(X)


def find_shortest_path(X: np.array) -> int:
    """
    Finds the length of the shortest path navigating a grid
    where each entry defines nodes weights and you can only navigate
    up, down, left and right

    Args:
        X (np.array): Grid weights

    Returns:
        int: path length
    """

    G = nx.DiGraph()

    n, m = X.shape

    for i in range(n):
        for j in range(m):
            G.add_node((i, j))

            for i1, j1 in get_neighbour_indices(i, j, n, m):
                G.add_edge((i, j), (i1, j1), weight=X[i1, j1])

    return int(
        nx.shortest_path_length(
            G, source=(0, 0), target=(n - 1, m - 1), weight="weight"
        )
    )


def get_big_map(X, multiplier=5):
    """
    generates a large (multiplier times larger each way) map containing
    grids of the original grid X where each grid is X += the 1-norm positions
    away from the original grid mod 10


    Args:
        X ([type]): [description]
        multiplier (int, optional): [description]. Defaults to 5.

    Returns:
        [type]: [description]
    """

    n, m = X.shape
    # initialise empty array
    X_l = np.zeros((n * multiplier, m * multiplier))

    # for each grid column
    for i in range(multiplier):
        # for each grid row
        for j in range(multiplier):
            # increase by 1-norm away
            X_s = X + i + j
            # for all the numbers above 10
            above_ten = X_s >= 10
            # increase by 1 and then mod 10
            X_s[above_ten] = X_s[above_ten] + 1
            X_s %= 10
            # add to larger array
            X_l[i * n : (i + 1) * n, j * m : (j + 1) * m] = X_s
    # return array
    return X_l


def get_neighbour_indices(i: int, j: int, n: int, m: int) -> Tuple[np.array]:
    """
    Returns the neighbouring (excluding diagonals) indices of
    i,j of a n x m array.

    Args:
        i (int): row indice
        j (int): column indice
        n (int): n rows
        m (int): m columns

    Returns:
        Tuple[np.array]: array of rows, array of columns
    """
    # get neighbouring rows
    rows = np.array([i - 1, i, i, i + 1])
    columns = np.array([j, j - 1, j + 1, j])
    # initialise list
    indices = []
    for k in range(4):
        # if values are not out of bound
        if not (rows[k] < 0 or rows[k] == n or columns[k] < 0 or columns[k] == m):
            # keep those values
            indices.append((rows[k], columns[k]))
    return indices


if __name__ == "__main__":
    print(part_one("aoc/inputs/day_15.txt"))
    print(part_two("aoc/inputs/day_15.txt"))
